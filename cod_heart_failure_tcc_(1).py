# -*- coding: utf-8 -*-
"""Cod_Heart_Failure_TCC (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1utLjhPReqBlenaYB8eiZEsaOWXrogKi6

# Código Heart Failure
"""



"""## Importações

### Pip install

Instalações !pip para algumas bibliotecas.

Sweetviz para uma análise rápida do dataset e Joblib para salvar os parâmetros e treino do modelo.
"""

!pip install sweetviz
!pip install joblib

"""### Import"""

import timeit
import numpy as np
import pandas as pd
import sweetviz as sv
import seaborn as sns
import tensorflow as tf
import missingno as msno
import statsmodels.api as sm
import matplotlib.pyplot as plt
import plotly.graph_objects as go

from keras import metrics
from sklearn.svm import SVC
from tensorflow import keras
from sklearn.metrics import *
from keras.optimizers import *
from tensorflow.keras import layers
from tensorflow.keras import backend
from sklearn.metrics import f1_score
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import confusion_matrix
from tensorflow.keras.utils import plot_model
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score

#import isolado para não causar erro
import joblib

"""### Download do dataframe

Dataframe pego do site kaggle e feito upload no github para melhor eficiência no download do arquivo csv.

https://www.kaggle.com/fedesoriano/heart-failure-prediction
"""

dataset = pd.read_csv("https://raw.githubusercontent.com/RF3758/K37PjOgE53/main/corazonfail.csv", sep=',',decimal='.', encoding = 'ISO-8859-1')

"""Variáveis:

Age: Idade em anos [years]

Sex: Sexo biológico [M: Male, F: Female]

ChestPainType: tTpo de dor no peito [TA: Typical Angina, ATA: Atypical Angina, NAP: Non-Anginal Pain, ASY: Asymptomatic]

RestingBP: Pressão sanguínea em repouso [mm Hg]

Cholesterol: Colesterol sérico [mm/dl]

FastingBS: Açúcar no sangue em jejum [1: if FastingBS > 120 mg/dl, 0: otherwise]

RestingECG: Resultados de eletrocardiograma em repouso [Normal: Normal, ST: having ST-T wave abnormality (T wave inversions and/or ST elevation or depression of > 0.05 mV), LVH: showing probable or definite left ventricular hypertrophy by Estes' criteria]

MaxHR: Frequência cardíaca máxima alcançada [Numeric value between 60 and 202]

ExerciseAngina: Angina induzida por exercício [Y: Yes, N: No]

Oldpeak: Depressão ST de repouso em exercício relativo [Numeric value measured in depression]

ST_Slope: Inclinação do segmento ST de pico do exercício [Up: upsloping, Flat: flat, Down: downsloping]

HeartDisease: Classe de saída [1: heart disease, 0: Normal]

## Análise exploratória no dataset

### Análise exploratória pelo SweetVIZ
"""

analise_sv = sv.analyze(dataset)

"""A análise feita no SweetVIZ é composta por "abas" que são as colunas no dataset. Ele informa o tipo de dado se é float, int ou string mostrando tipos de características para cada dytpe.

As informações dadas nas análises incluem dados em gráficos de quantidade de variáveis, relação entre variáveis ao clicar na aba como também menores e maiores valores, dados estatísticos como média e outros tipos. Na opção "ASSOCIATIONS" na área de dados gerais do dataframe, mostra um tipo de matriz de confusão entre os dados do dataset.
"""

analise_sv.show_notebook()

"""### Análise exploratória por funções pandas"""

dataset.head(10)

dataset.info()

dataset.count()

#.T gera uma matriz invertida na grade de dados
dataset.describe().T

"""### Análise dos dados para substituição"""

print('FastingBS',dataset['FastingBS'].unique())
print('HeartDisease',dataset['HeartDisease'].unique())
print('Sex',dataset['Sex'].unique())
print('ExerciseAngina',dataset['ExerciseAngina'].unique())
print('ST_Slope',dataset['ST_Slope'].unique())
print('RestingECG',dataset['RestingECG'].unique())
print('ChestPainType',dataset['ChestPainType'].unique())

dataset = dataset.astype({'Sex' : 'string'})
dataset = dataset.astype({'ChestPainType' : 'string'})
dataset = dataset.astype({'RestingECG' : 'string'})
dataset = dataset.astype({'ExerciseAngina' : 'string'})
dataset = dataset.astype({'ST_Slope' : 'string'})
dataset = dataset.astype({'FastingBS' : 'string'})
#dataset = dataset.astype({'HeartDisease' : 'string'})

dataset['Sex'] = dataset['Sex'].replace(['M','F'],['1','2'])
dataset['FastingBS'] = dataset['FastingBS'].replace(['0','1'],['1','2'])
#dataset['HeartDisease'] = dataset['HeartDisease'].replace(['0','1'],['1','2'])
dataset['ExerciseAngina'] = dataset['ExerciseAngina'].replace(['N','Y'],['1','2'])
dataset['ST_Slope'] = dataset['ST_Slope'].replace(['Down', 'Flat', 'Up'],['1','2','3'])
dataset['RestingECG'] = dataset['RestingECG'].replace(['Normal', 'ST', 'LVH'],['1','2','2'])
dataset['ChestPainType'] = dataset['ChestPainType'].replace(['TA','ATA','NAP','ASY'],['4','3','2','1'])

print(dataset['Sex'].unique())
print(dataset['ST_Slope'].unique())
print(dataset['FastingBS'].unique())
print(dataset['RestingECG'].unique())
print(dataset['ChestPainType'].unique())
print(dataset['ExerciseAngina'].unique())

dataset = dataset.apply(pd.to_numeric)

dataset.info()

"""### Gráficos

"""

plt.figure(figsize=(12,8))
ax = sns.heatmap(dataset.corr(), cmap='YlGnBu', annot=True)
plt.show()

dataset[dataset.dtypes[(dataset.dtypes=="float64")|(dataset.dtypes=="int64")].index.values].hist(figsize=[11,11])

"""## X e Y"""

filps = {'HeartDisease': 0}
dataset = dataset.fillna(value=filps)

dataset = dataset.dropna()

x = dataset.drop('HeartDisease', axis = 1)
y = dataset['HeartDisease']

print("x =",len(x),"/","y =",len(y),"/","df =",len(dataset))

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2)

x_train

y_train

"""### MinMax"""

scmm = MinMaxScaler()
mm_x_train = scmm.fit_transform(x_train)
mm_x_test = scmm.transform(x_test)

mm_x_train

x_train

"""### StandardScaler"""

ssr = StandardScaler()
ssr_x_train = ssr.fit_transform(x_train)
ssr_x_test = ssr.fit_transform(x_test)

svc = SVC(kernel='linear', C=10.0)
svc.fit(ssr_x_train, y_train)

ssr_x_train

ssr_x_test

"""## Regressão logística

### Modelo
"""

lg_model = LogisticRegression(random_state = 745, max_iter = 1000).fit(x_train, y_train)

"""### Save Model"""

file_lg_model = "LG_Model.pkl"

joblib.dump(lg_model, file_lg_model )

LG_Model = joblib.load(file_lg_model)

LG_Model

"""### Predição

Os pontos vermelhos representam os valores previstos que são 1 ou 2,
a linha e o ponto azul representam o valor real do paciente.
"""

lg_y_pred = lg_model.predict(x_test)

atual = []
predicao = []

for i,j in zip(y_test,lg_y_pred):
  atual.append(i)
  predicao.append(j)
dic = {'Actual':atual,'Prediction':predicao}
lg_heart_result  = pd.DataFrame(dic)

fig = go.Figure()
fig.add_trace(go.Scatter(x=np.arange(0,len(y_test)), y=y_test,mode='markers+lines',name='Teste'))
fig.add_trace(go.Scatter(x=np.arange(0,len(y_test)), y=lg_y_pred,mode='markers', name='Predict'))

lg_heart_result

"""### Accuracy score"""

accuracy_score(y_test, lg_y_pred)

"""### Classification report"""

print(classification_report(y_test,lg_y_pred))

"""### Confusion matrix"""

cm = confusion_matrix(y_test, lg_y_pred)
sns.heatmap(cm, annot = True)

"""## MLP

### Modelo
"""

tf.keras.backend.clear_session()

model_in = tf.keras.models.Sequential()

model_in.add(tf.keras.layers.Dense(15, activation='sigmoid'))
model_in.add(tf.keras.layers.Dense(10, activation='sigmoid'))
model_in.add(tf.keras.layers.Dense(7, activation='sigmoid'))
model_in.add(tf.keras.layers.Dense(5, activation='sigmoid'))
model_in.add(tf.keras.layers.Dense(1, activation='sigmoid'))

# opt = [tf.keras.optimizers.SGD(learning_rate=0.01, momentum=0.9),
#        tf.keras.optimizers.Adamax(learning_rate=0.004, beta_1=0.9, beta_2=0.999, epsilon=1e-07, name="Adamax")]
model_in.compile(loss=['binary_crossentropy'],
                 optimizer=tf.keras.optimizers.Adamax(learning_rate=0.004, beta_1=0.9, beta_2=0.999, epsilon=1e-07, name="Adamax"),
                 metrics=['accuracy'])

"""### Treino"""

mlp_loss = pd.DataFrame(model_in.fit(x_train, y_train, epochs=200, batch_size=13, verbose=1, validation_split=0.20).history).to_csv("epoch_history.csv")

"""### Save model"""

model_in.summary()
plot_model(model_in,
           to_file='model.png',
           show_shapes=True)

file_mlp = "MLP_Model.pkl"

joblib.dump(model_in, file_mlp )

MLP_Model = joblib.load(file_mlp)

MLP_Model

"""### Epoch history"""

mlp_loss = pd.read_csv('/content/epoch_history.csv', sep=',',decimal='.', encoding = 'ISO-8859-1')

mlp_loss

"""### Loss e Accuracy"""

plt.figure(figsize=(14,5), dpi=80, facecolor='w', edgecolor='k')

plt.title("LOSS")
plt.xlabel("Épocas")
plt.ylabel("Loss")
plt.plot(mlp_loss['loss'], label="Loss/Época")
plt.plot(mlp_loss['val_loss'], label="Val Loss/Época")

plt.legend()
plt.show()

plt.figure(figsize=(14,5), dpi=80, facecolor='w', edgecolor='k')

plt.title("Exatidão")
plt.xlabel("Época")
plt.ylabel("Accuracy")
plt.plot(mlp_loss['accuracy'], label="accuracy/Época")
plt.plot(mlp_loss['val_accuracy'], label="Val accuracy/Época")

plt.legend()
plt.show()

mlp_loss['accuracy'].mean()

"""### Predição"""

cm_y_pred = svc.predict(ssr_x_test)

conf_matrix = confusion_matrix(y_true=y_test, y_pred=cm_y_pred)

fig, ax = plt.subplots(figsize=(5, 5))
ax.matshow(conf_matrix, cmap=plt.cm.Oranges, alpha=0.3)

for i in range(conf_matrix.shape[0]):
  for j in range(conf_matrix.shape[1]): ax.text(x=j, y=i,s=conf_matrix[i, j], va='center', ha='center', size='xx-large')

plt.xlabel('Predição', fontsize=18)
plt.ylabel('Atual', fontsize=18)
plt.title('Confusion Matrix', fontsize=18)

plt.show()

mlp_y_pred = model_in.predict(mm_x_test)

atual = []
predicao = []

for i,j in zip(y_test,lg_y_pred):
  atual.append(i)
  predicao.append(j)
dic = {'Actual':atual,'Prediction':predicao}
mlp_heart_result  = pd.DataFrame(dic)

mlp_heart_result

# mlp_y_pred = model_in.predict(mm_x_test)
# real_y_pred = scmm.inverse_transform(mlp_y_pred)
# mlp_y_pred = model_in.predict(mm_x_test)
# mlp_y_pred = scmm.inverse_transform(mlp_y_pred)